

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


CREATE EXTENSION IF NOT EXISTS "pgsodium";






COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgjwt" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";





SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."entry_patterns" (
    "id" integer NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "user_id" "uuid" NOT NULL
);


ALTER TABLE "public"."entry_patterns" OWNER TO "postgres";


COMMENT ON TABLE "public"."entry_patterns" IS 'Stores user-defined entry patterns or confirmation strategies.';



COMMENT ON COLUMN "public"."entry_patterns"."user_id" IS 'Links the entry pattern to the user who created it.';



CREATE SEQUENCE IF NOT EXISTS "public"."entry_patterns_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "public"."entry_patterns_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."entry_patterns_id_seq" OWNED BY "public"."entry_patterns"."id";



CREATE TABLE IF NOT EXISTS "public"."pairs" (
    "id" bigint NOT NULL,
    "name" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "pairs_name_check" CHECK (("char_length"("name") >= 6))
);


ALTER TABLE "public"."pairs" OWNER TO "postgres";


COMMENT ON TABLE "public"."pairs" IS 'Stores predefined Forex currency pairs.';



ALTER TABLE "public"."pairs" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."pairs_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."strategies" (
    "id" bigint NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "strategies_name_check" CHECK (("char_length"("name") >= 1))
);


ALTER TABLE "public"."strategies" OWNER TO "postgres";


COMMENT ON TABLE "public"."strategies" IS 'Stores user-defined trading strategies.';



ALTER TABLE "public"."strategies" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."strategies_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."trades" (
    "id" bigint NOT NULL,
    "user_id" "uuid" DEFAULT "auth"."uid"() NOT NULL,
    "pair" "text" NOT NULL,
    "pair_id" bigint NOT NULL,
    "strategy_id" bigint,
    "strategy_tag" "text",
    "entry_date" timestamp with time zone NOT NULL,
    "exit_date" timestamp with time zone NOT NULL,
    "is_long" boolean NOT NULL,
    "entry_price" double precision NOT NULL,
    "exit_price" double precision NOT NULL,
    "position_size_lots" double precision NOT NULL,
    "stop_loss_price" double precision,
    "take_profit_price" double precision,
    "actual_profit_loss" double precision,
    "commission_fees" double precision,
    "swap_fees" double precision,
    "reason_for_entry" "text",
    "reason_for_exit" "text",
    "confidence_score" integer,
    "custom_tags_json" "text",
    "image_paths_json" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "audio_file_path" "text",
    "setup_timeframe" "text",
    "entry_timeframe" "text",
    "entry_pattern_id" integer,
    CONSTRAINT "trades_pair_check" CHECK ((("char_length"("pair") >= 6) AND ("char_length"("pair") <= 10)))
);


ALTER TABLE "public"."trades" OWNER TO "postgres";


COMMENT ON TABLE "public"."trades" IS 'Stores individual Forex trade logs.';



COMMENT ON COLUMN "public"."trades"."setup_timeframe" IS 'Timeframe used for trade setup/context (e.g., H4, D1).';



COMMENT ON COLUMN "public"."trades"."entry_timeframe" IS 'Timeframe used for trade entry/confirmation (e.g., M5, M15).';



COMMENT ON COLUMN "public"."trades"."entry_pattern_id" IS 'Links to the specific entry pattern used from the entry_patterns table.';



ALTER TABLE "public"."trades" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."trades_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



ALTER TABLE ONLY "public"."entry_patterns" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."entry_patterns_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."entry_patterns"
    ADD CONSTRAINT "entry_patterns_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."entry_patterns"
    ADD CONSTRAINT "entry_patterns_user_id_name_key" UNIQUE ("user_id", "name");



ALTER TABLE ONLY "public"."pairs"
    ADD CONSTRAINT "pairs_name_key" UNIQUE ("name");



ALTER TABLE ONLY "public"."pairs"
    ADD CONSTRAINT "pairs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."strategies"
    ADD CONSTRAINT "strategies_name_key" UNIQUE ("name");



ALTER TABLE ONLY "public"."strategies"
    ADD CONSTRAINT "strategies_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."trades"
    ADD CONSTRAINT "trades_pkey" PRIMARY KEY ("id");



CREATE INDEX "idx_trades_entry_date" ON "public"."trades" USING "btree" ("entry_date");



CREATE INDEX "idx_trades_user_id" ON "public"."trades" USING "btree" ("user_id");



ALTER TABLE ONLY "public"."entry_patterns"
    ADD CONSTRAINT "entry_patterns_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."trades"
    ADD CONSTRAINT "trades_entry_pattern_id_fkey" FOREIGN KEY ("entry_pattern_id") REFERENCES "public"."entry_patterns"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."trades"
    ADD CONSTRAINT "trades_pair_id_fkey" FOREIGN KEY ("pair_id") REFERENCES "public"."pairs"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."trades"
    ADD CONSTRAINT "trades_strategy_id_fkey" FOREIGN KEY ("strategy_id") REFERENCES "public"."strategies"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."trades"
    ADD CONSTRAINT "trades_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



CREATE POLICY "Allow authenticated insert access" ON "public"."pairs" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow authenticated insert access" ON "public"."strategies" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow authenticated read access" ON "public"."pairs" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow authenticated read access" ON "public"."strategies" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow authenticated update access" ON "public"."pairs" FOR UPDATE TO "authenticated" USING (true) WITH CHECK (true);



CREATE POLICY "Allow authenticated update access" ON "public"."strategies" FOR UPDATE TO "authenticated" USING (true) WITH CHECK (true);



CREATE POLICY "Allow individual delete access" ON "public"."trades" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Allow individual insert access" ON "public"."trades" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Allow individual select access" ON "public"."trades" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Allow individual update access" ON "public"."trades" FOR UPDATE USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can manage their own entry patterns" ON "public"."entry_patterns" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."entry_patterns" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."pairs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."strategies" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."trades" ENABLE ROW LEVEL SECURITY;




ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";


GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";












































































































































































































GRANT ALL ON TABLE "public"."entry_patterns" TO "anon";
GRANT ALL ON TABLE "public"."entry_patterns" TO "authenticated";
GRANT ALL ON TABLE "public"."entry_patterns" TO "service_role";



GRANT ALL ON SEQUENCE "public"."entry_patterns_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."entry_patterns_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."entry_patterns_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."pairs" TO "anon";
GRANT ALL ON TABLE "public"."pairs" TO "authenticated";
GRANT ALL ON TABLE "public"."pairs" TO "service_role";



GRANT ALL ON SEQUENCE "public"."pairs_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."pairs_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."pairs_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."strategies" TO "anon";
GRANT ALL ON TABLE "public"."strategies" TO "authenticated";
GRANT ALL ON TABLE "public"."strategies" TO "service_role";



GRANT ALL ON SEQUENCE "public"."strategies_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."strategies_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."strategies_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."trades" TO "anon";
GRANT ALL ON TABLE "public"."trades" TO "authenticated";
GRANT ALL ON TABLE "public"."trades" TO "service_role";



GRANT ALL ON SEQUENCE "public"."trades_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."trades_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."trades_id_seq" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "service_role";






























RESET ALL;
